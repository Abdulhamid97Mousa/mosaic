# Trainer Orchestrator — Phase 2 Blueprint (Artifacts & Metrics)

## Executive Summary

Phase 2 wires CleanRL’s artifact firehose (MP4 captures, TensorBoard logs, Weights & Biases runs) into the trainer stack **without** compromising the telemetry-first contract that keeps the GUI responsive and auditable. CleanRL remains an inspirational reference; the actual implementation path will begin with a simple CLI trainer derived from `spadeBDI_RL_refactored`, and the GUI must be ready to ingest its outputs as soon as that CLI speaks the agreed telemetry protocol. The deliverable is a run experience where the GUI can surface videos, metrics, and external dashboards when they exist, yet still operate flawlessly when they do not.

---

## 1. CleanRL Outputs vs. GUI Expectations

### What CleanRL Already Ships (and Where)

- **Video Capture** → Gymnasium’s `RecordVideo` wrapper records MP4s when `--capture-video` is passed; assets land under `videos/<run_name>/…` just as CleanRL’s docs describe.
- **TensorBoard Logs** → `SummaryWriter` stores event files inside `runs/<run_name>/…`; running `tensorboard --logdir runs` finds them immediately.
- **Weights & Biases (“--track”)** → With valid creds, `wandb.init()` streams metrics/media to the project and prints the run URL (also mirrored in `wandb/latest-run.json`).

### What the GUI Must Do

- **Replay Tab** → Telemetry replay remains default; if MP4 artifacts exist, surface a “Play Video” button.
- **Metrics Tabs** → Enable TensorBoard/W&B views only for runs whose manifests include those artifacts; grey out otherwise.
- **Artifact Awareness** → Discover what CleanRL already wrote; never guess or require artifacts to exist.

---

## 2. Implementation Plan (Telemetry-First)

### A. Artifact Discovery & Indexing

1. **Worker exit hook** scans the run’s working directory for:
	 - `videos/<run_name>/*.mp4` (RecordVideo output)
	 - `runs/<run_name>/` TensorBoard event files
	 - WANDB run URL (parse from stdout or `wandb/latest-run.json`)
2. **Emit an `ArtifactManifest`** back to the daemon (JSON/protobuf) describing video paths, TensorBoard roots, and W&B URLs.
3. **RunRegistry update** persists the manifest inside the existing JSON metadata column (`artifact_manifest`) so the GUI can retrieve it after restarts.

### B. GUI Integration

- **Replay Tab**
	- Default to telemetry playback (StepRecord/EpisodeRollup already flowing via TelemetryService).
	- If `artifact_manifest.videos` exists → enable “Play Video” (QtMultimedia `QMediaPlayer` or open with OS default player).
- **TensorBoard Tab**
	- If `artifact_manifest.tensorboard` exists → show a “Launch TensorBoard” button.
		- Option 1: spawn `tensorboard --logdir=<path> --port=<free_port>` and embed via `QWebEngineView`.
		- Option 2: open user’s browser (less risk, zero Qt dependencies).
- **Weights & Biases Tab**
	- If `artifact_manifest.wandb_url` exists → show “Open in W&B” button (external browser).
- **Tab Visibility Rules**
	- Agent runs: enable metrics/video tabs when artifacts present.
	- Human runs: grey out or hide; telemetry replay remains available.

### C. Telemetry ↔ Artifact Bridge

- Extend the gRPC `RunEvent` stream to include `artifact_manifest` deltas whenever the daemon indexes artifacts.
- `TrainerClientRunner` listens for the update, emits Qt signals, and toggles UI controls in place.
- If the manifest is empty (no MP4/W&B), the replay tab quietly stays in telemetry-only mode—no errors, no stale buttons.

### D. Retention & Cleanup

- Add artifact knobs to `StorageProfile` (e.g., `max_videos_per_run`, `max_runs_per_agent`).
- Background janitor removes oldest MP4s/logs once limits hit; emit `ArtifactPruned` events so the GUI can refresh.
- Expose retention status in the settings pane (“2/5 videos retained”).

---

## 3. Bridging the Gap: From “RUNNING” to Episode Visibility

The current control plane (daemon → dispatcher → worker) delivers reliable process lifecycle management, but STDOUT text alone does not give the GUI research-grade observability. We need a structured bridge that turns the CLI trainer (starting with `spadeBDI_RL_refactored`) into a first-class citizen of the existing TelemetryService, JSONL recorder, and replay widgets.

### 3.1 Why plain logs are insufficient

- **SQLite WAL is already the right foundation** — writers in WAL mode do not block readers, so the daemon can ingest telemetry while the GUI queries it simultaneously.
- **Structured streams beat raw logs** — newline-delimited JSON (JSONL) lets us parse each event incrementally and forward it directly into TelemetryService without buffering or ad-hoc parsing.
- **Qt threading discipline** — blocking I/O must live in a worker thread; Qt’s queued connections then marshal events safely onto the UI thread. The planned bridge thread already aligns with Qt’s guidance.
- **Video != replay** — MP4s are shareable artifacts, but telemetry-driven replay remains lighter, richer, and scrubbable. We keep MP4 export optional.

### 3.2 Worker → Daemon telemetry protocol (JSONL over stdout)

Every trainer worker (CLI, CleanRL-inspired, or otherwise) prints one JSON object per line:

- `config` events: run metadata, hyperparameters, seeds, env id.
- `step` events: episode id, step index, action, reward, terminated/truncated flags, optional observation summary or RGB payload.
- `episode` rollups: episode length, return, completed timestamp.
- `metric` events: scalar metrics (losses, learning rate, evaluation scores).

Example lines:

```
{"type":"config","run_id":"...","algo":"ppo","env_id":"LunarLander-v3","seed":123,"args":{...}}
{"type":"step","episode_id":"...","step":42,"action":1,"reward":1.0,"terminated":false,"truncated":false,"obs":{...},"t":1700.512}
{"type":"episode","episode_id":"...","steps":512,"return":241.7,"t_end":1712.004}
{"type":"metric","name":"policy_loss","value":0.0042,"t":1712.100}
```

This stream complements (not replaces) CleanRL’s TensorBoard/W&B integrations; those remain optional sinks for external dashboards.

### 3.3 Dispatcher responsibilities

- Launch workers with stdout/stderr pipes and read them asynchronously (`async for line in proc.stdout:`).
- `json.loads` each line (with guardrails) and route on `event["type"]`:
	- `config` → persist on the run record for reproducibility.
	- `step` → build a `StepRecord` and push into TelemetryService (`record_step`).
	- `episode` → build an `EpisodeRollup`, call `complete_episode`, and notify StorageRecorderService.
	- `metric` → forward to a lightweight metrics sink or broadcast inline.
- Emit lightweight status updates on `RunEventBroadcaster` so the GUI list reflects “last step time / latest return”.

### 3.4 GUI attachment strategy

- Extend `TrainerClientRunner` with streamed RPCs that pipe `StepRecord`/`EpisodeRollup` into a `QThread` bridge.
- The bridge emits Qt signals (`stepReceived`, `episodeReceived`) which SessionController can connect to the existing replay and telemetry panels.
- Add `SessionController.attach_to_training_run(run_id)` to subscribe to those signals so training runs reuse the identical UI flows as human play.



### 3.6 gRPC surface extensions

- Add `StreamSteps(StreamStepsRequest{run_id})` and `StreamEpisodes(StreamEpisodesRequest{run_id})` streaming RPCs to `TrainerService`.
- The daemon fans out parsed JSONL events to those streams in addition to writing them into storage.
- The GUI bridge thread blocks on those calls (off the UI thread) and emits Qt signals for live updates.

### 3.7 Checkpoint hygiene (already planned)

- Continue periodic `wal_checkpoint(TRUNCATE)` in the daemon to keep WAL files lean.
- Log `(busy, log_frames, checkpointed_frames)` so stuck readers are obvious.

### 3.8 TL;DR for the CLI-first rollout

1. Start with the `spadeBDI_RL_refactored` CLI emitting JSONL as described.
2. Dispatcher parses, persists, and rebroadcasts those events into TelemetryService.
3. GUI attaches via streaming RPCs + Qt queued signals, reusing existing replay panels.
4. Artifacts (MP4, TensorBoard, W&B) remain optional enhancements on top of this telemetry spine.

---

## 5. Contrarian Take — Avoid the Usual Traps

| Anti-pattern | Why It Fails | Contrarian Fix |
|--------------|--------------|----------------|
| **Video as primary replay** | MP4s bloat storage, aren’t scrubbable, and lose per-step context. | Keep telemetry as the canonical replay path; video is a bonus. |
| **Hardwired W&B/TensorBoard UI** | Breaks offline, behind firewalls, or when credentials absent. | Treat them as optional integrations; degrade gracefully. |
| **Artifact hoarding** | Disk fills up, run directories become garbage dumps. | Enforce retention policies and make pruning visible. |

Principle: **Artifacts are optional enhancements, not dependencies.** The GUI must never regress when videos or dashboards are missing.

---

## 6. Implementation Details (Per Component)

### Trainer Worker

- Accept `--capture-video` and `--track` flags (already supported by CleanRL CLI).
- After process exit:
	- `glob("videos/{run_name}/*.mp4")`
	- `pathlib.Path("runs/{run_name}")` exists?
	- Parse WANDB info (`wandb/latest-run.json` or environment vars).
- During execution, emit newline-delimited JSON (`JSONL`) telemetry from the shim launcher so every step/episode flows into `TelemetryService` in real time.
- Send the artifact manifest back via stdout JSON line or control pipe, e.g.:

```json
{
	"event": "artifacts",
	"run_id": "...",
	"video": "/abs/path/videos/run/episode0.mp4",
	"tensorboard": "/abs/path/runs/run_name/",
	"wandb_url": "https://wandb.ai/..."
}
```

### Trainer Daemon

- Parse manifest, update RunRegistry (`artifact_manifest` JSON column), and broadcast `RunEvent.ArtifactsAvailable`.
- Trigger retention janitor if limits exceeded.
- Persist relative paths using helper in `config/paths.py` to keep directories relocatable.

### GUI Layer

- `TrainerClientRunner` listens for artifact events → emits Qt signal with manifest.
- `RenderTabs` keeps telemetry default; toggles MP4 button using manifest presence.
- New `MetricsTabs` component shows:
	- “Launch TensorBoard” (spawns process + opens web view/external browser).
	- “Open in W&B” (calls `QtGui.QDesktopServices.openUrl`).
- Tabs stay greyed out when artifacts absent or run is human-controlled.

### Storage & Retention

- Extend `StorageRecorderService` profiles with `max_video_artifacts`, `max_tensorboard_runs`.
- Implement janitor task in daemon: delete oldest assets, log pruning, notify GUI.
- Surface retention result in GUI’s settings pane/log console.

---

## 7. UI Narrative (Happy Path)

1. User starts agent run with video + metrics enabled.
2. Run completes → daemon receives manifest and stores it.
3. GUI receives `ArtifactsAvailable` event:
	 - Replay tab shows “Play Video”.
	 - Metrics pane enables “Launch TensorBoard” and “Open in W&B”.
4. User plays MP4 (Qt player or external).
5. User opens TensorBoard (embedded or browser).
6. W&B tab opens external dashboard when credentials available.

If any artifact is missing, the UI simply omits/greys the corresponding control while telemetry replay remains intact.

---

## 8. Risk Register & Mitigations

- **Disk Bloat** → Enforce retention + prune; show usage indicators.
- **Missing Artifacts** → UI defaults to telemetry replay; no crashes.
- **WANDB Offline** → Button disabled with tooltip (“Enable --track and login to use W&B”).
- **TensorBoard Port Collisions** → Use `socket.bind(('', 0))` to find free port; show error toast if launch fails.
- **GUI Freeze** → Launch TensorBoard/MP4 playback in background threads/processes; never block Qt event loop.
- **Parallel Storage Universes** → Prevent drift by piping worker JSONL telemetry into existing `TelemetryService` rather than inventing a separate metrics pipeline.

---

## 9. Final Contrarian Guidance

- **Telemetry is the source of truth; artifacts are shareable frosting.**
- **Design for absence** (no `--capture-video`, no W&B creds) before polishing the deluxe path.
- **Loose coupling wins** — expose URLs, spawn viewers out-of-process, and keep Qt reactive.
- **Stream JSONL telemetry** so training runs inhabit the same replay spine as human runs.
- **Show retention status** so users understand why artifacts disappear.

Deliver this blueprint and Phase 2 becomes a disciplined upgrade instead of a sprawling side quest.- **Loose coupling wins** — expose URLs, spawn viewers out-of-process, and keep Qt reactive.
- **Stream JSONL telemetry** so training runs inhabit the same replay spine as human runs.
- **Show retention status** so users understand why artifacts disappear.

Deliver this blueprint and Phase 2 becomes a disciplined upgrade instead of a sprawling side quest.