# qt-material: Theme Pipelines with Jinja and Runtime Color Exports

`qt_material.apply_stylesheet()` is more than a call to `setStyleSheet()`. The library treats theming as a build pipeline: XML theme files flow through Jinja templates, icons are recolored on the fly, and the final QSS is stitched with platform-aware flags before being applied. The result is a reusable way to ship design systems across PyQt5/6 and PySide2/6.

## What makes the pipeline shine
- **Jinja-templated QSS.** `build_stylesheet()` loads `material.css.template`, registers filters like `opacity()` and `density()`, and renders CSS with theme variables plus environment flags (`linux`, `windows`, binding name). Tweaking layout density or button shapes becomes a one-line XML change.
- **Automatic icon regeneration.** `set_icons_theme()` feeds the selected colors into `ResourseGenerator`, writing SVG variants (primary/disabled) and wiring them into Qt’s search path (`QDir.addSearchPath('icon', …)`) so your UI grabs theme-matched assets instantly.
- **Environment export for extensions.** `get_theme()` pushes every color into `os.environ['QTMATERIAL_*']`. Downstream code can extend the stylesheet or export palette data without re-parsing XML.
- **Binding/order agnostic.** The module checks `sys.modules` to decide whether to import PyQt or PySide classes, so the same pipeline runs regardless of which binding you imported first.
- **Runtime customization hooks.** The `extra` dict lets callers inject semantic colors (`danger`, `warning`, `success`) or nested options (`QMenu` overrides) before rendering, keeping brand tweaks out of the core template.

## Mermaid: from XML to live stylesheet
```mermaid
graph TD
    Caller[apply_stylesheet(app, theme, extra)] --> Style[build_stylesheet]
    Style --> Theme[get_theme(theme_name)]
    Theme -->|parse XML| Palette{theme dict}
    Palette --> Env[export QTMATERIAL_* env vars]
    Palette --> Icons[set_icons_theme]
    Icons -->|generate SVGs| SearchPaths[QDir.addSearchPath]
    Style --> Template[Jinja render material.css.template]
    Template --> QSS[Rendered stylesheet]
    Caller -->|optional css_file| Merge[Append custom CSS]
    Merge --> Apply[app.setStyleSheet(QSS)]
```

## Adapting the pattern for your design system
1. **Store palette data separately.** Keep colors in XML/JSON/YAML; parse them once and turn results into plain dicts so you can reuse the data for icons, env exports, or docs.
2. **Render styles via templates.** Feed the palette into a Jinja (or similar) template with helper filters. This beats manually concatenating strings and makes density/opacity rules declarative.
3. **Recolor assets programmatically.** Use a generator step to recolor SVGs/PNGs per theme and register a custom Qt search path. Your UI just references `icon:save` regardless of the active theme.
4. **Expose overrides.** Accept an `extra` mapping or callback for callers to tweak accent colors, fonts, or component-specific tweaks without forking the template.
5. **Set env/state for consumers.** Export the current theme to environment variables or a global config so widgets outside the stylesheet (e.g., Matplotlib views) can align their colors.
6. **Support multiple bindings.** Detect whether the host app uses PySide or PyQt and import the matching Qt classes dynamically to avoid import-order pitfalls.

Deploy this pipeline early and your PyQt/PySide app gains Material-like consistency, theming hot-swaps, and a clean escape hatch for product designers who want to script their own palettes.
