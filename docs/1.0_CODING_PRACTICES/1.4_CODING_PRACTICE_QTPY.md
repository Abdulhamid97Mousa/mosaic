# QtPy: Binding-Aware Tooling for Type-Safe Multi-Qt Projects

QtPy wraps the import differences between PyQt5/6 and PySide2/6 into a single shim so you can write `from qtpy.QtWidgets import QApplication` and let the library find whichever binding is installed. Beyond the import layer, the project includes a small CLI that keeps your static analysis, docs, and packaging scripts aligned with the binding that actually loads on the machine.

### Project snapshot
- **Primary goal:** expose a stable package namespace (`qtpy.QtCore`, `qtpy.QtWidgets`, …) no matter which Qt binding is installed.
- **Detection flow:** environment variable `QT_API` → optional `QT_API_ENV` hints → auto-detect installed bindings → emit a `PythonQtWarning` if the preferred binding is missing.
- **Developer tooling:** the `qtpy` console script proxies to `qtpy/cli.py`, providing `mypy-args`, `pyright-config`, and `bindings` subcommands.
- **Typed hints:** stub files live in `qtpy/_patch`, and the CLI reuses them to tell Pyright/Mypy which constants are truthy or falsy for a given binding.

| Component | Why it matters |
| --- | --- |
| `qtpy/__init__.py` | Negotiates the binding and exposes shim modules mirroring Qt’s API surface. |
| `qtpy/cli.py` | Builds an `argparse` CLI that prints dynamic settings for type checkers. |
| `qtpy/_patch` | Contains per-binding adjustments so behavior matches PyQt/PySide quirks. |
| `qtpy/tests/test_cli.py` | Regression suite proving the CLI outputs stay in sync with detection logic. |

QtPy’s standout practice isn’t just abstracting over PyQt and PySide at runtime—it ships a tiny developer CLI (`qtpy/cli.py`) that **projects the active binding into your static analysis tools**. Instead of hand-maintaining `pyrightconfig.json` or `mypy.ini`, you run `qtpy mypy-args` or `qtpy pyright-config` and the command emits binding-specific flags pulled straight from `qtpy.API`.

## Why this matters
- **Single source of truth for the binding.** The same detection logic used at runtime (`qtpy.__init__`) drives CLI output, so your type checker always sees the exact API (PyQt5/6 or PySide2/6) that QtPy selected.
- **Zero-config onboarding.** New contributors can run one command to copy/paste the right `--always-true/false` switches for Mypy or the constants block for Pyright; no tribal knowledge needed.
- **Future-proof upgrades.** When QtPy adds a binding or deprecates a version, the CLI output changes automatically—teams inherit the new guidance without touching docs.
- **Encapsulated warnings.** If a requested binding isn’t installed, QtPy falls back and warns via `PythonQtWarning`, ensuring the CLI mirrors what actually loads in-process.

## Architecture at a glance (text-friendly)
```
QT_API / auto-detect ──▶ qtpy.__init__
                               │
                               ├─ Loads shim modules (QtCore, QtWidgets, ...)
                               ├─ Records active API name (PYQT5, PYSIDE6, ...)
                               ▼
                    qtpy.cli (argparse subcommands)
                               │
                               ├─ mypy-args     → prints --always-true/false switches
                               ├─ pyright-config→ prints JSON/TOML defineConstant block
                               └─ bindings      → shows detected + fallback bindings
```

## Bringing it into your own PyQt/PySide library
1. **Expose the runtime decision.** Keep the binding negotiation (`QT_API`, fallbacks, warnings) in a module import side-effect, just as QtPy does in `qtpy/__init__.py`.
2. **Write a thin CLI.** Use `argparse` to route subcommands that format tool-specific outputs from the negotiated state.
3. **Derive, don’t duplicate.** Call the same helper that the rest of your library uses to know the active API—no environment-probing twice.
4. **Cover type checkers first.** Start with Mypy and Pyright (they unlock most IDE integrations), then consider pylance/ruff extras as your users ask.
5. **Document the workflow.** Add a “Static analysis” section to your README showing the one-line commands; your contributors will actually use the tooling if it’s obvious.

### Typical workflow
```text
$ python -m pip install qtpy mypy pyright
$ export QT_API=pyqt6           # or leave unset and let auto-detect run
$ qtpy bindings                 # sanity check which API loaded
Active Qt API: PYQT6 (preferred)
$ mypy src $(qtpy mypy-args)    # hey presto: correct truthy/falsy constants
$ qtpy pyright-config > pyrightconfig.json
```

### Troubleshooting tips
- **`PythonQtWarning: No Qt bindings could be found.`** Install one (`pip install pyqt5`) or set `QT_API` to a binding you actually ship.
- **Mixed environments (PyQt + PySide installed).** QtPy picks the first binding in `QT_API_PRIORITY`. Override with `QT_API=pyside6` when you need a specific runtime.
- **CLI not on PATH.** Re-run `pip install --force-reinstall qtpy` or call `python -m qtpy.cli` directly.

### Learning checklist
- [ ] My project exposes a single import surface regardless of PyQt/PySide flavor.
- [ ] CLI output is sourced from the same runtime detection logic.
- [ ] Static analysis configs regenerate automatically during CI.
- [ ] Documentation shows the one-liners contributors must run.
- [ ] Warnings guide users toward installing the right binding.

## Quick start template
```text
$ pip install qtpy
$ qtpy mypy-args
--always-true=PYQT5 --always-false=PYSIDE2 --always-false=PYQT6 --always-false=PYSIDE6
$ mypy src $(qtpy mypy-args)
```

Building this tooling loop early means your MVC or MVVM layers stay clean while teammates enjoy precise auto-complete and type feedback, regardless of the Qt binding they’ve installed.
