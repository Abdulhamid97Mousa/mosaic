# MOSAIC Refactoring Plan for Multi-Agent Support (Unreal-MAP Readiness)

This doc enumerates the gym_gui directories that must evolve from single-agent wiring to true multi-agent awareness, aligns each refactor with upcoming Unreal-MAP integration, and clarifies why the current structure blocks MARL. Sections: (1) architecture diagnosis, (2) refactor scope per directory, (3) sequencing tied to Unreal fast-lane/HMAP, (4) open questions.

## 1. Architectural Diagnosis

1. **Main window + presenters (single-agent assumptions).** Files: `gym_gui/ui/main_window.py`, `ui/presenters/main_window_presenter.py`, `ui/panels/control_panel_container.py`, `ui/panels/telemetry_container.py`. Control flow assumes one `SessionController` → one set of tabs. Side effects:
   - Render tabs are keyed by a single `session_id` with no per-agent sub-tabs.
   - TensorBoard/W&B tab naming (e.g., `WAND-Agent-{agent_id}`) still bound to `agent_id=0`.
2. **Worker presenters/catalog.** Files: `ui/presenters/workers/*.py`, `ui/workers/catalog.py`, `ui/forms/factory.py`.
   - Each presenter couples UI forms to a single worker process (CleanRL or SPADE BDI). No notion of a multi-team configuration or mixing worker types per session.
3. **Widgets and tabs.** Key files: `ui/widgets/control_panel.py`, `live_telemetry_tab.py`, `base_telemetry_tab.py`, `render_tabs.py`, `fastlane_tab.py`, `telemetry_tab_protocol.py`, `spade_bdi_worker_tabs/`, `cleanrl_train_form.py`, `spade_bdi_train_form.py`, `jason_supervisor_form.py`, `tensorboard_artifact_tab.py`, `wandb_artifact_tab.py`.
   - `live_telemetry_tab` index is keyed by run ID only; no per-agent filtering.
   - `fastlane_tab` expects one shared memory ring per run. Unreal multi-agent scenarios will need per-team/per-camera streams.
4. **Environment directories.** `ui/environments/single_agent_env` is fully fleshed out; `ui/environments/multi_agent_env` is skeletal. Need explicit environment descriptors for MARL tasks (team metadata, spawn positions, reward channel info) to drive the control panel.
5. **Renderers/QML.** Fast-lane QML (`ui/renderers/fastlane_item.py`, `ui/qml/FastLaneView.qml`) currently draws a single frame overlay. For Unreal multi-agent we may need overlays per agent (bounding boxes, HUD per team). We need a data model that passes agent metadata from the adapter to the renderer.

## 2. Refactor Scope

| Area | Files | Refactor Actions | Rationale & Unreal/HMAP tie-in |
| --- | --- | --- | --- |
| **Session → Multi-surface MVC** | `main_window.py`, `main_window_presenter.py`, `analytics_tabs.py`, `control_panel_container.py`, `ui/panels/*`, (new) `ui/shared/session_surface.py` | Create `SessionSurface` dataclass capturing `run_id`, `agent_slot`, `team_label`, `fastlane_channels`. Presenter maintains a list of surfaces per run and routes telemetry/render events accordingly. Control panel uses the surface model to spawn per-agent controls (pause, seeding, notes). | Unreal-MAP scenarios (see `/unreal-map/Docs`, `PythonExample/`) define teams and agents explicitly; modeling them as `SessionSurface`s is the cleanest way to bind that metadata to the GUI. Shared base stays in `ui/shared`, specific logic in `single_agent_*.py` / `multi_agent_*.py` modules. |
| **Worker catalog & descriptors** | `ui/workers/catalog.py`, `ui/presenters/workers/*.py`, `ui/forms/factory.py`, `workers/__init__.py`, `spade_bdi_*` forms, (new) `ui/workers/descriptors.py` | Introduce `WorkerDescriptor` dataclasses with fields (`name`, `modes`, `max_agents`, `telemetry_schema`). Populate descriptors using existing CleanRL/BDI wrappers (`3rd_party/cleanrl_worker`, `3rd_party/spade_bdi_worker`) plus future HMAP worker. Catalog groups descriptors into `single_agent` vs `multi_agent`. Worker presenters read descriptors instead of hard-coded values. | HMAP configs (under `/unreal-map/PythonExample/` and `Docs/HMAP`) define how many teams/algorithms run together. Encoding that in descriptors lets the UI build forms for “Team A uses MAPPO, Team B uses rule-based policy” without manual wiring. |
| **Telemetry tabs + RunBus validation** | `live_telemetry_tab.py`, `base_telemetry_tab.py`, `telemetry_tab_protocol.py`, `telemetry_container.py`, `ui/widgets/telemetry_tab_protocol.py`, `gym_gui/logging_config/log_constants.py`, `gym_gui/services/telemetry/schema_validator.py`, (new) `ui/widgets/ma_telemetry_tab.py` | Extend telemetry schemas (protobuf + JSONL validators) to require `agent_slot`, `team_label`, `scenario_id`. Log constants enforce naming and make logs searchable (`LOG_UI_MULTI_AGENT_TAB_CREATED`). Implement `MultiAgentTelemetryView` subclassing the base tab, with per-agent filters and aggregated views. | Unreal’s event system emits per-agent events (kills, pickups). HMAP also logs per-team stats. Enforcing schema fields ensures we can map those events to the right tabs; the new MA view actually renders them. |
| **Render + fast lane** | `render_tabs.py`, `fastlane_tab.py`, `fastlane_consumer.py`, `fastlane_item.py`, `ui/qml/FastLaneView.qml`, (new) `ui/renderers/multi_agent_overlay.py` | Allow multiple shared-memory rings per run using a naming convention: `var/fastlane/run_<id>/agent_<slot>/camera_<n>.shm`. `FastLaneConsumer` iterates over surfaces, attaches to each ring, and pushes frames into `FastLaneView` with metadata overlays (team color, agent name). Add optional split-view layout. | Unreal integration references show multiple cameras (e.g., spectator + first-person). This setup can handle single or multiple streams. Naming ensures we can clean up rings per agent. |
| **Artifacts (TensorBoard/W&B)** | `tensorboard_artifact_tab.py`, `wandb_artifact_tab.py`, `ui/widgets/tensorboard_artifact_tab.py`, `ui/widgets/wandb_artifact_tab.py`, logging bridge, storage configs | Directory scheme: `var/artifacts/run_<id>/agent_<slot>/<tool>/`. Tabs read descriptors to generate agent dropdowns. Logging bridge stamps events with `agent_slot` to aid filtering. Optional aggregator view that overlays metrics from multiple agents. | CleanRL already logs per-run metrics via sitecustomization; new scheme extends that pattern. HMAP workers can adopt the same directory structure so the UI doesn’t need custom logic. |
| **Environment metadata** | `ui/environments/single_agent_env`, `ui/environments/multi_agent_env`, `ui/environments/__init__.py`, `gym_gui/config/game_configs.py`, (new) `ui/environments/descriptors.py` | Build a registry of `MultiAgentEnvironmentDescriptor` objects that mirror Unreal-MAP scenarios (map name, team count, asset refs). Parse scenario metadata from `/unreal-map/Docs` or `PythonExample` scripts so we stay consistent with upstream. Control panel loads descriptors and configures forms accordingly. | Unreal explicitly separates map and task definitions—matching that in MOSAIC ensures we don’t hard-code scenario details. |
| **Log constants + validation** | `gym_gui/logging_config/log_constants.py`, `ui/logging_bridge.py`, `services/telemetry/schema_validator.py`, `controllers/*` | Add constants like `LOG_MULTI_AGENT_SURFACE_CREATED`, `LOG_FASTLANE_CHANNEL_ATTACHED`. Logging bridge enforces new formats (warn when single-agent log emitted from multi-agent codepath). Schema validator ensures RunBus events include required fields. | Rich logs/validation are critical when juggling multiple agents; fast failures prevent silent data corruption. |
| **Naming conventions + directories** | entire `ui/` tree, README, lint scripts | Adopt the “shared / single_agent / multi_agent” pattern: move reusable utilities to `ui/shared`, keep existing files under `single_agent`, add new modules under `multi_agent`. Document naming rules (e.g., `ma_control_panel.py`, `ma_render_tab.py`). Create a lint script that checks imports to prevent `single_agent` modules from pulling `multi_agent` ones. | Makes the transition explicit without duplicating logic. Shared code lives in one place, mode-specific code gets obvious names. |

## 3. Sequencing (Coupled with Unreal Integration)

1. **Phase 0 – Audit & naming.** Catalog all single-agent assumptions (done via this doc). Define naming conventions and directory structure for multi-agent widgets/presenters.
2. **Phase 1 – UI refactor skeleton.** Implement `SessionSurface` and `MultiAgentTelemetryView` scaffolding. Adjust main window/presenters to support multiple surfaces even if only one active. Update logging bridge/log constants to handle surface creation.
3. **Phase 2 – Fast lane multi-stream.** Extend fast-lane consumer/tab to handle multiple shared-memory rings and metadata overlays. Use synthetic data (e.g., two ToyText agents) to verify layout.
4. **Phase 3 – Environment descriptors + worker forms.** Populate `multi_agent_env` registry with descriptors extracted from Unreal docs (start with one scenario). Update worker forms to accept team assignments based on descriptors.
5. **Phase 4 – Unreal install & schema inspection.** Build `/home/hamid/Desktop/Projects/GUI_BDI_RL/unreal-map` via the provided scripts (`Please_Run_This_First_To_Fetch_Big_Files.py`, build scripts) and run `PythonExample` to capture their telemetry payloads. Document mapping between Unreal IDs and MOSAIC surfaces.
6. **Phase 5 – HMAP worker + Unreal integration.** Wrap HMAP into a `WorkerDescriptor`, implement the adapter/harness that streams Unreal telemetry to the RunBus and fast lane using the new naming scheme. Validate multi-agent UI end-to-end.

## 4. Open Questions / Design Decisions

1. **Per-team vs per-agent processes.** Should MOSAIC spawn one worker per team (MAPPO team, rule-based team) or rely on a single HMAP process controlling multiple teams? Need to define how `WorkerDescriptor` encodes this so UI/presenter logic knows whether to spawn multiple PIDs or one multi-team worker.
2. **Shared-memory naming scheme.** Fast-lane files must follow a deterministic pattern (e.g., `mosaic.fastlane.<run>.agent<slot>.camera<idx>`) to avoid collisions. Evaluate whether Unreal can expose multiple cameras per agent or just a composite view.
3. **Artifact storage & cleanup.** With per-agent TensorBoard/W&B logs, define retention/cleanup knobs (maybe piggyback existing storage profiles). Need script to prune old `run_<id>/agent_<slot>` dirs.
4. **Schema alignment.** Unreal’s Python API tags actors/teams; we must map them to MOSAIC `agent_id`/`team_label`. Document the mapping and enforce via schema validator and log constants.
5. **Testing strategy.** Build a minimal multi-agent harness (e.g., ToyText two-player) to exercise UI/logging before Unreal integration. Add CI tests verifying multi-agent telemetry ingestion and fast-lane multi-stream rendering.
6. **Validation pipeline.** Decide whether to extend `schema_validator.py` or add `multi_agent_schema_validator.py`. Tie validation errors into log warnings to help future debugging.
7. **Unreal integration proof.** After building the UE repo, capture an actual telemetry log (from `PythonExample`) and verify the new schema catches missing fields. Document in this plan so reviewers see concrete evidence the interface is compatible.

This refactoring plan must precede any credible Unreal-MAP integration. Without it, we would be streaming MARL telemetry into a GUI that still thinks one agent equals one tab, undermining the whole “heterogeneous control plane” narrative.
