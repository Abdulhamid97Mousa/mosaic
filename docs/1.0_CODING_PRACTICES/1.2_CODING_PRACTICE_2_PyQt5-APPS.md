# PyQt5-Apps: Qt Designer Views + Controller Mixins for Clean Separation

`PyQt5-Apps` is a portfolio of 10+ desktop utilities (Google Translate helper, FFmpeg front-end, word recorder, calendar generator, etc.) written by Lewis Tian. Every tool follows the same UI pattern: draw the interface once in Qt Designer, auto-generate a `Ui_*` class, and then compose a controller that mixes in the generated class with concrete behavior. That consistency makes the repo a great learning lab for scaling Qt Designer projects without tangling logic and layout.

### Project snapshot
- **Run any app** with `python path/to/app/main.py` after `pip install -r requirements.txt` (PyQt5, googletrans, requests, PyMySQL, etc.).
- **Repository layout** mirrors the app names (`google-translate/`, `words-recorder/`, `ffmpeg-helper/`, ...); each folder contains a `mwin.ui` (or similar), the generated `mwin.py`, a themed `style.qss`, and a `main.py` controller.
- **Generated files shout “do not edit.”** At the top of the `Ui_*` modules you’ll see the guard comment: _“WARNING! All changes made in this file will be lost!”_
- **Controllers stay lean and testable.** Services (HTTP clients, DB helpers) are imported as plain Python modules so they can be mocked in unit tests.

| App | Purpose | Controller trick worth copying |
| --- | --- | --- |
| `google-translate` | Clipboard-aware translator with real-time mode | Centralized `connectSlots` method and UI language switching via `QTranslator` |
| `words-recorder` | Vocabulary notebook backed by MySQL | Injects database helpers into the controller, keeps raw SQL outside the UI class |
| `ffmpeg-helper` | Quick FFmpeg wrapper for merge/extract tasks | Uses controller mixins to populate combo boxes from config files |
| `cat-calendar` | Daily wallpaper/calendar generator | Shows how to combine HTTP responses with QPixmaps without touching designer code |

Across the sample apps in `PyQt5-Apps`, the author keeps presentation and behavior split by pairing **auto-generated `Ui_*` classes with handcrafted controller subclasses**. A typical window (`google-translate/main.py::MyWindow`) inherits from both `QMainWindow` and the generated `Ui_MWin`, calls `setupUi(self)` once, then binds slots in a dedicated `connectSlots()` helper. Other apps (`words-recorder/main.py`, `cat-calendar/main.py`) follow the same recipe, so style sheets, i18n, and business logic evolve without touching the designer files in `mwin.py` or `ui/*.py`.

## Why this practice works
- **Designer files stay throwaway.** `mwin.py` is explicitly marked "WARNING! All changes made in this file will be lost!"—logic lives in `main.py`, so regenerating from `mwin.ui` never stomps behavior.
- **Controllers read like narrations.** Methods such as `MyWindow.connectSlots()` group all signal-slot wiring, making it easy to audit new interactions and apply shortcuts (`self.go.setShortcut("CTRL+Return")`).
- **Multiple backends, one view.** The same UI class powers MySQL-backed (`words-recorder`) or HTTP-backed (`google-translate`) controllers; switching storage layers becomes a matter of swapping controller mixins.
- **Easy theming and localization.** Controllers load QSS themes (`style.qss`) and `QTranslator` instances after `setupUi`, keeping design assets outside generated code.

## Architecture at a glance (text-friendly)
```
Qt Designer (.ui) ──▶ pyuic ──▶ Ui_MWin class
                                        ▲
                                        │ multiple inheritance
MyWindow(QMainWindow, Ui_MWin) ──▶ setupUi(self) once
                                        │
                                        ├─ connectSlots(): signal ↔ slot wiring
                                        ├─ load_theme(): read style.qss
                                        ├─ inject_services(): pass Translator/DAO/etc.
                                        ▼
                               Business helpers (e.g., googletrans, PyMySQL)
```

## Reusing the pattern in your own app
1. **Design first, code second.** Sketch forms in Qt Designer, export them with `pyuic` (or let `pyqtgraph.Qt.loadUiType` handle it lazily). Never edit the generated file.
2. **Compose your window/controller.** Create `class MainWindow(QMainWindow, Ui_MainWindow)` and call `self.setupUi(self)` in `__init__`.
3. **Centralize slot wiring.** Put signal/slot hookups in one method (like `connectSlots`) so adding commands is declarative. Prefer lambdas or `functools.partial` to keep signatures clean.
4. **Inject services logically.** Pass translators, data access objects, or config paths into the controller so the UI layer depends on abstractions instead of global state.
5. **Leverage inheritance for variants.** For multi-skin apps, subclass the controller and override only resource loading (`loadStylesheet`, `bindShortcuts`).

### Hands-on exercise (15 minutes)
1. Copy `google-translate/mwin.ui` to a new folder and rename the window title to your project name in Qt Designer.
2. Run `pyuic5 mwin.ui -o mwin.py` and create a `main.py` like the snippet below.
3. Replace the `Translator` service with a plain Python function (e.g., reverse the text) to prove the UI/controller boundary works.
4. Add a new menu item to `connectSlots()` and confirm it only touches `main.py`.

```python
class MainWindow(QMainWindow, Ui_MWin):
    def __init__(self, translator, parent=None):
        super().__init__(parent)
        self.setupUi(self)
        self.translator = translator
        self.connectSlots()

    def connectSlots(self):
        self.go.clicked.connect(self.translate)

    def translate(self):
        self.transText.setPlainText(self.translator(self.originText.toPlainText()))
```

### Learning checklist
- [ ] I can regenerate designer files without losing logic.
- [ ] Signal-slot wiring for a window lives in one place.
- [ ] Business helpers are passed in, not imported globally.
- [ ] `style.qss` or translators load after `setupUi(self)`.
- [ ] My tests instantiate the controller and inject fakes for services.

## Bonus: testing hooks
Because logic lives in the controller, you can instantiate the window in tests without a full event loop, swap services with fakes, and assert on widget state. This practice is a natural stepping stone toward MVVM/MVP once your project grows.
