# Trainer Orchestration Pre-GUI Hardening Summary

## Changes Applied

This document captures the seven critical fixes implemented before GUI integration.

### 1. Worker Dispatcher & State Progression ✅

**Files Created:**
- `gym_gui/services/trainer/dispatcher.py` - New async dispatcher managing worker lifecycle

**Functionality:**
- `TrainerDispatcher` polls PENDING runs every 2 seconds
- State transitions: PENDING → DISPATCHING → RUNNING → (COMPLETED | FAILED | CANCELLED)
- Spawns subprocess workers with:
  - Isolated process groups (`os.setsid` / `preexec_fn`)
  - GPU slot enforcement via `CUDA_VISIBLE_DEVICES`
  - Async stdout/stderr streaming (prevents PIPE deadlocks)
- Monitors exit codes and reconciles terminal states
- SIGTERM → SIGKILL escalation (5s timeout)
- Publishes `RunRecord` updates through broadcaster callback
- Symmetric GPU release on worker completion/failure

**Integration:**
- Daemon instantiates dispatcher in `run()` method
- Dispatcher starts three async tasks: dispatch loop, monitor loop, heartbeat checker
- Shutdown sequence stops dispatcher before gRPC server

---

### 2. Digest-Based Deduplication ✅

**Files Modified:**
- `gym_gui/services/trainer/registry.py`

**Changes:**
- Added `UNIQUE` constraint on `digest` column in `runs` table schema
- `register_run()` now returns existing `run_id` if digest already exists (idempotent)
- `SubmitRun` RPC handler checks for duplicate digest and returns existing run without re-reservation

**Rationale:**
- Original `run_id` included timestamp salt → different run_ids for identical configs
- Digest (SHA-256 of canonical config) is deterministic and stable
- Enables idempotent retries and prevents duplicate submissions

---

### 3. Symmetric GPU Release ✅

**Files Modified:**
- `gym_gui/services/trainer/dispatcher.py`

**Functionality:**
- `_reconcile_worker()` always calls:
  - `gpu_allocator.release_many([run_id])`
  - `registry.update_gpu_slots(run_id, [])`
- Applies to all terminal states: COMPLETED, FAILED, CANCELLED
- Heartbeat timeout path also releases GPU slots before marking FAILED

**Previous Gap:**
- Only `CancelRun` explicitly released GPU slots
- Normal completion/failure relied on shutdown cleanup

---

### 4. Transaction Guards ✅

**Files Modified:**
- `gym_gui/services/trainer/registry.py`

**Changes:**
- `claim_gpu_slot()` now wraps SELECT…UPDATE sequence in explicit `BEGIN IMMEDIATE` transaction
- Rollback on insufficient slots or errors
- Commit only after all slot updates succeed

**Rationale:**
- Prevents allocation races if multiple daemon processes claim slots concurrently
- Single daemon is safe, but explicit transaction future-proofs against multi-instance scenarios

---

### 5. Broadcaster Warning Logs ✅

**Files Modified:**
- `gym_gui/services/trainer/service.py`

**Changes:**
- `RunEventBroadcaster.publish()` logs at WARNING level when dropping messages due to full queue
- Includes `run_id` and `seq_id` in log context
- Deduplicates log emission per publish call (single warning for multiple stuck listeners)

**Rationale:**
- Slow GUI/CLI consumers can cause queue backpressure
- Operator visibility into stuck clients for debugging

---

### 6. Enum Mapping Defenses ✅

**Files Modified:**
- `gym_gui/services/trainer/service.py`

**Changes:**
- `_status_to_proto()` logs WARNING if unknown `RunStatus` encountered, returns `RUN_STATUS_UNSPECIFIED`
- `_proto_to_statuses()` logs WARNING for unknown proto enum values (excluding `UNSPECIFIED`)

**Rationale:**
- Defensive against future schema bumps or corrupted data
- Prevents silent failures when new enum values are added

---

### 7. Heartbeat Timeout Monitor ✅

**Files Modified:**
- `gym_gui/services/trainer/dispatcher.py`

**Functionality:**
- `_heartbeat_loop()` runs every 30 seconds
- Checks `last_heartbeat` timestamp for RUNNING runs
- Marks runs FAILED with `failure_reason="worker_timeout"` if stale beyond 300s (configurable)
- Releases GPU slots and terminates tracked worker process
- Publishes updated `RunRecord`

**Configuration:**
- Default timeout: 300 seconds (5 minutes)
- Constructor param: `heartbeat_timeout`

---

## Verification

All modules compiled successfully:
```bash
python -m compileall gym_gui/services/trainer/dispatcher.py  # ✓
python -m compileall gym_gui/services/trainer/registry.py     # ✓
python -m compileall gym_gui/services/trainer/service.py      # ✓
python -m compileall gym_gui/services/trainer_daemon.py       # ✓
```

## Integration Points

- Daemon instantiates `TrainerDispatcher` during startup
- Dispatcher receives broadcaster callback to publish `RunRecord` updates
- Registry schema migration handles UNIQUE constraint gracefully (existing DBs will error on duplicate digest insert)
- All terminal state transitions now enforce symmetric resource cleanup

## Next Steps

1. **Worker Command Builder**: Implement `_build_worker_command()` to parse `config_json` and extract `entry_point` + `arguments`
2. **Artifact Management**: Wire worker stdout/stderr into structured log files under `VAR_LOGS_DIR`
3. **GUI Bridge**: Connect `WatchRuns` stream to Qt signals via `TrainerClientRunner`
4. **Integration Tests**: Validate dispatcher lifecycle, GPU allocation/release, heartbeat timeout, and idempotent submission
5. **TLS Configuration**: Add certificate provisioning for non-loopback deployments

## Dependencies

No new external dependencies introduced. All changes use existing:
- `asyncio` for subprocess management
- `sqlite3` with transaction guards
- `logging` with structured context
- gRPC streaming already in place

---

**Status**: Pre-GUI hardening complete. Ready for Qt bridge integration.
